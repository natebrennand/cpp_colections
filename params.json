{"name":"Cpp collections","tagline":"","body":"\r\n# Tutorial\r\n\r\nIndex:\r\n\r\n- [Getting Started](#getting-started)\r\n- [Creating Collections](#creating-collections)\r\n- [Non-Member Functions for Collections](#non-member-functions-for-collections)\r\n- [Simple Member Functions for Collections](#simple-member-functions-for-collections)\r\n  - [Returning Collections](#returning-collections)\r\n  - [List Processing](#list-processing)\r\n- [Advanced Member Functions for Collections](#advanced-member-functions-for-collections)\r\n  - [Mapping functions](#mapping-functions)\r\n  - [Reduction functions](#reduction-functions)\r\n  - [Fold and scan Functions](#fold-and-scan-functions)\r\n- [Creating Streams](#creating-streams)\r\n- [Non-Member Functions for Streams](#non-member-functions-for-streams)\r\n  - [Alternative Stream Creation Tactics](#alternative-stream-creation-tactics)\r\n  - [Prepend Values](#prepend-values)\r\n  - [Zipping Streams](#zipping-streams)\r\n- [Member Functions for Streams](#member-functions-for-streams)\r\n  - [List Processing Functions](#list-processing-functions)\r\n  - [Filtering Function](#filtering-function)\r\n  - [Mapping function](#mapping-function)\r\n- [Conclusion](#youre-done)\r\n\r\nWe begin with a swift introduction to C++ Collections.\r\nOur goal is to show the main elements of this library as quickly as possible.\r\nRather than getting caught up in details, rules, exceptions - we want to allow users to make useful programs as quickly as possible.\r\n\r\nUnlike the standard design documentation, which provides a list of all methods available and their uses, we prefer brevity over depth here.\r\nThis is completely intentional, and we encourage more experienced programmers to refer to our design document to cement their understanding of C++ Collections.\r\n\r\n## Getting Started\r\n\r\nIn order to run C++ Collections, [download][repo_download] and `#include cpp_collections.h`.\r\n\r\nYou can then start by creating either a Collection or a Stream object.\r\nThe difference between a Collection and a Stream object is:\r\n\r\n- Collections are traditional functional abstractions on lists are used to define finite lists.\r\n- Streams are self-referential lazily-evaluated data structures that allow for the definition of infinite lists.\r\n\r\n## Creating Collections\r\n\r\n(We assume that we are using namespace `std` for all examples.)\r\n\r\nThe Collection is used to represent a finite list. Let's create an empty one.\r\n\r\n```cpp\r\nauto empty_collection = Collection<int>();\r\n```\r\n\r\nWith this empty collection we can demonstrate a number of member functions.\r\nLet's call the `size()` method.\r\n\r\n```cpp\r\nint x = empty_collection.size();\r\n\r\nstd::cout << x << std::endl\r\n// 0\r\n```\r\n\r\nNow, rather than instantiating an empty list, we can instantiate a list with a predetermined size.\r\n\r\n```cpp\r\nauto presized_collection = Collection<int>(5);\r\n\r\nstd::cout << presized_collection << std::endl;\r\n// [0,0,0,0,0]\r\n```\r\n\r\nThis can be validated immediately by running the following:\r\n\r\n```cpp\r\nstd::cout << presized_collection.size() << std::endl;\r\n// 5\r\n```\r\n\r\nBecause Collections use a `std::vector` to store its data internally, the `size()` method of a Collection simply calls `size()` on its internal `std::vector`.\r\nMoreover, this implementation detail means that we can easily create a Collection from a `std::vector`.\r\n\r\n```cpp\r\nvector<int> v {1,2,3,5,7};\r\nauto vector_collection = Collection<int>(v);\r\n```\r\n\r\nIn addition to `std::vector`, we can also create a Collection from a `std::list`.\r\n\r\n```cpp\r\nlist<int> l = {1,2,3,4};\r\nauto list_collection = Collection<int>(l); \r\n```\r\n\r\nWe can also use `std::array` and C-style arrays.\r\n\r\n```cpp\r\narray<int, 6> foo  = {1, 1, 2, 3, 5, 8};\r\nauto array_collection = Collection<int>(foo);  // std::array\r\n\r\nint foo [5] = { 16, 2, 77, 40, 12071 };\r\nauto c_array_collection = Collection<int>(foo, 5); // C-style array\r\n\r\n```\r\n\r\nAs mentioned above, the Collection class uses a `std::vector` to store data internally.\r\nThis allows Collections to not only remain fast, but reliable.\r\nAlthough we use integers for most of our examples here, the Collection can handle any type due to the type agnosticism of vectors. \r\n\r\n## Non-Member Functions for Collections\r\n\r\nAlthough the Collection constructor provides a simple way to instantiate a Collection, the C++ Collections library contains several non-member functions that make this process easier.\r\n\r\nIf you want to return a Collection of numeric types over the range `[0, size)` use the `range()` function.\r\nNote that the Collection returned by `range()` contains whatever type you passed to `range()` initially.\r\n\r\n```cpp\r\nauto a = range(5);\r\ncout << a << endl;\r\n\r\n// [0,1,2,3,4]\r\n\r\n\r\nauto f = range(float(5));\r\ncout << f << endl;\r\n\r\n// [0.0,1.0,2.0,3.0,4.0]\r\n```\r\n\r\n`range()` can also be used with lower and upper bounds, returning a Collection over the range `[low, high)`.\r\n\r\n```cpp\r\nauto b = range(5, 10);\r\ncout << b << endl;\r\n\r\n// [5,6,7,8,9]\r\n```\r\n\r\nWe can also concatenate an arbitrary number of Collections together by using the `concat()` function.\r\n\r\n```cpp\r\nauto a = range(5);\r\nauto b = range(5,10);\r\nauto c = range(5);\r\ncout << concat(a, b, c) << endl;\r\n\r\n// [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4]\r\n```\r\n\r\nNeed to use multiple Collections together for an operation?\r\nThe `zip()` function combines multiple Collections into a single Collection of tuples.\r\nA [tuple](http://www.cplusplus.com/reference/tuple/) is a dynamically created object that can hold multiple different types.\r\n\r\n```cpp\r\nauto a = range(5);\r\nauto b = range(5,10);\r\nauto ab = zip(a, b);\r\n\r\ncout << ab << endl;\r\n// [(0,5), (1,6), (2,7), (3,8), (4,9)]\r\n```\r\n\r\nTuples can also hold elements with different types, meaning that `zip()` can be called on Collections of different types as well.\r\nIn the following example we see that `zip()` returns a new Collection of tuples that include an `int`, `float`, and `char`.\r\n\r\n```cpp\r\nauto e = range(3);\r\nauto f = range(float(3.0));\r\nauto g = Collection(std::vector<char> {'e','f','g'});\r\n\r\nauto efg = zip(e, f, g);\r\ncout << efg << endl;\r\n// [(0,0.0,'e'), (1,1.0,'f'), (2,2.0,'g')]\r\n```\r\n\r\n`zipWith()` generalizes the functionality provided by `zip()` by allowing us to pass any function to be applied to the members of the zipped lists.\r\nHere we zip two Collections together, *with* a lambda function that adds the members of the Collections together.\r\n\r\n```cpp\r\nauto a = range(3);\r\nauto b = range(3);\r\nauto sums = zipWith([](int x, int y) { return x+y; }, a, b)\r\n\r\nstd::cout << sums << std::endl;\r\n// [0,2,4]\r\n```\r\n\r\n## Simple Member Functions for Collections\r\n\r\n### Returning Collections\r\n\r\nNow that we understand the different ways we can create a Collection, how can we return the data from a Collection?\r\nSince Collections are stored as vectors, the `vector()` method simply returns the internal data object.\r\n\r\n```cpp\r\n// returns a std::vector of size 5 with elements 0,1,2,3,4 \r\nauto c = range(5);\r\nstd::vector<int> v = c.vector();\r\n```\r\n\r\nWhat happens if we want to return a list?\r\n\r\n```cpp\r\n// returns a std::list of size 5 with elements 0,1,2,3,4 \r\nstd::list<int> l = Collection<int>(5).list();\r\n```\r\n\r\n### List Processing\r\n\r\nFor processing Collections, the C++ Collections library exposes a set of operations that are common in functional langauges.\r\nFirstly, in order to maintain consistency with the list data structures of Haskell and Scala, we implement the `head()`, `last()`, `init()`, and `tail()` functions.\r\n\r\nThe `head()` function returns the first element in the Collection.\r\nThe `last()` function returns the last element in the Collection\r\n\r\n```cpp\r\nauto col = range(1,11);\r\n\r\ncout << col.head(); << endl;\r\n// 1\r\n\r\ncout << col.last(); << endl;\r\n// 10\r\n```\r\n\r\nThe `init()` function returns a new Collection with all elements except the last.\r\nThe `tail()` function returns a new Collection with all elements except the head.\r\n\r\n```cpp\r\nauto col = range(1,11);\r\ncout << col.init() << endl;\r\n\r\n// [1,2,3,4,5,6,7,8,9]\r\n```\r\n\r\nWhat would happen if we called `init()` on our Collection *before* printing it?\r\n\r\n```cpp\r\nauto col = range(1,11);\r\n\r\ncol.init()\r\ncout << col << endl;\r\n// [1,2,3,4,5,6,7,8,9,10]\r\n\r\nauto new_col = col.init()\r\ncout << new_col << endl;\r\n// [1,2,3,4,5,6,7,8,9]\r\n```\r\n\r\nThis example might be confusing initially, but the concept it illustrates is central to functional programming. \r\n`init()` does not mutate the internal `std::vector` of the Collection is is called on but instead returns a new Collection with a new `std::vector` inside.\r\nIn fact, both `init()` and `tail()` return modified *copies* of the original Collection object, as do `zip()`, `zipWith()`, and other, more advanced functions we will see a little later.\r\n\r\nThis means that we can use all these functions together to do create arbitrarily complex Collections.\r\nHere, we create a list of ten odd numbers.\r\n\r\n```cpp\r\nauto s = range(11);\r\ns = zipWith([](int x, int y) {return x+y;}, s, s.tail());\r\nstd::cout << s << std::endl;\r\n\r\n// [1,3,5,7,9,11,13,15,17,19]\r\n```\r\n\r\n## Advanced Member Functions for Collections\r\n\r\nNow that we have covered basic member functions of Collections we can move on to more advanced member functions.\r\n\r\nC++11 lambdas allow us to pass functions as parameters, giving us lots of interesting functionality for advanced member functions.\r\nOne of the most basic examples of this is the `each()` function, which allows us to pass a function to be executed once for every element in the Collection.\r\n\r\n```cpp\r\nint sum = 0;\r\nauto a = range(5);\r\na.each([&](int x) {\r\n    sum += x;\r\n});\r\nstd::cout << sum << std::endl;\r\n\r\n// 10\r\n```\r\n\r\nThe `filter()` function is similar to the `each()` function, except that the function passed to it must return a boolean value.\r\n`filter()` will test each element with this predicate function and return a subset of the original Collection with the elements that pass the predicate.\r\nSimilar to the example above, let's attempt to print a list of odd numbers with `filter()`.\r\n\r\n```cpp\r\nstd::cout << range(20).filter([](int x) { return x % 2 != 0; }) << std::endl;\r\n\r\n// [1,3,5,7,9,11,13,15,17,19]\r\n```\r\n\r\nLet's assume we only want the fourth and fifth odd numbers in our Collection.\r\nThe `slice()` method returns a new Collection with the elements whose indices are within the range `[low, high)`.\r\n\r\n```cpp\r\nstd::cout << range(20).filter([](int x) { return x % 2 != 0; }).slice(3,5) << std::endl;\r\n\r\n// [7,9]\r\n```\r\n\r\n### Mapping functions\r\n\r\nOne of the key concepts in functional programming is the `map()` function.\r\n`map()` allows us to apply an arbitrary transformation (passed as a C++11 lambda) to all the elements of the Collection.\r\n\r\n```cpp\r\nstd::cout << range(3).map([](int x) { return x+1; }) << std::endl;\r\n\r\n// [1,2,3]\r\n```\r\n\r\nThe `tmap()` function achieves the same effect as `map()`, but uses multiple concurrent `std::threads` to speed up processing.\r\nYou can pass the number of threads you would like to execute your transformation with as the second argument to `tmap()` (default is set to `std::thread::hardware_concurrency()`, or, if that returns 0, 4).\r\n\r\n```cpp\r\nstd::cout << range(3).tmap([](int x) { return x+1; }, 3) << std::endl;\r\n\r\n// [1,2,3]\r\n```\r\n\r\nAll functions that are prefixed with the character 't' are multithreaded and can be passed the number of threads to execute with as their final parameter.\r\n\r\n### Reduction functions\r\n\r\nIn an example above, we used the `each()` function with an external variable to sum the values in a Collection.\r\nThis was not the traditionally functional way of achieving this.\r\nReduction functions return a single value which is the result of the application of the same binary operator on adjacent pairs of elements in the Collection.\r\n`reduceLeft()` applies the binary operator starting from the left, and `reduceRight()` applies the binary operator starting from the right (or last element).\r\n\r\nHere we use `reduceLeft()` to find the sum of the integers 0 - 4. \r\n\r\n```cpp\r\nint sum = range(5).reduceLeft([](int x, int y) { return x+y; });\r\nstd::cout << sum << std::endl;\r\n\r\n// 10\r\n```\r\n\r\nIt is worth diving into this a little bit more, and inspecting the state of the Collection at each step of the reduction.\r\n\r\n```cpp\r\nbegin : 0,1,2,3,4\r\nstep 1:   1,2,3,4\r\nstep 2:     3,3,4\r\nstep 3:       6,4\r\nstep 4:        10\r\n```\r\n\r\nReduction functions move pairwise across the Collection, applying the same binary operator on each pair that it finds. \r\n\r\nSimilar to `tmap()`, we also have `treduce()`, an alternative implementation of reduce that uses multiple concurrent threads to speed up processing.\r\nNote that the function passed to `treduce()` must be commutative to achieve accurate results, becuase we cannot guarantee that all binary reductions will occurr in the expected order when working with multiple threads.\r\n\r\n```cpp\r\nint sum = range(5).treduce([](int x, int y) { return x+y; }, 3);\r\nstd::cout << sum << std::endl;\r\n\r\n// 10\r\n```\r\n\r\n### Fold/Scan Functions\r\n\r\nWe have two fold functions: `foldLeft()` and `foldRight()`.\r\n\r\nThis returns the result of the application of the same binary operator on all elements in the Collection as well as an initial value, starting from the left.\r\nFolds are just the same as reductions, except that they start with an initial value, meaning that a fold can return a type different from that stored in the original Collection, while a reduction cannot.\r\n\r\n```cpp\r\nint sum = range(5).foldLeft([](int x, int y) { return x+y; }, 0);\r\nstd::cout << sum << std::endl;\r\n\r\n// 10\r\n```\r\n\r\nIn addition to the fold functions, we can also return the intermediate results of the binary accumulation of elements in a Collection with `scanLeft()` and `scanRight()`.\r\n\r\n```cpp\r\nauto ints = range(1,5);\r\nauto ints2 = ints.scanLeft([](int x, int y) { return x+y; }, 1);\r\nstd::cout << ints2 << std::endl;\r\n\r\n// [1,2,4,7,11]\r\n```\r\n\r\n## Creating Streams\r\n\r\nCreating Streams is a different from creating Collections.\r\nThe key differentiating factor between Streams and Collections is that Streams can be used to represent potentially infinite lists of data.\r\nThese infinite Streams can then be converted to finite Collections using the `take()` function. \r\n\r\nFirst, let's create an infinite Stream of 1s.\r\n\r\n```cpp\r\nstd::function<Stream<int>()> ones_gen = [&]() { return Stream<int>(1, ones_gen) };\r\nStream<int> ones = Stream<int>(1, ones_gen);\r\n```\r\n\r\nLet's break down what is happening here. \r\nStreams are self-referential data structures, meaning that in addition to the head, or the first value in the list, the class stores a pointer to a function that returns another Stream.\r\nHere, we define a function `ones_gen()` that return a new Stream with a head of 1 and a generator function `ones_gen()`.\r\nWe then construct the new Stream `ones` with the default Stream constructor, passing the initial head value of 1, and the generator function `ones_gen()`.\r\n\r\nNow, we can take an arbitrary number of elements out of this Stream with the `take()` function.\r\n\r\n```cpp\r\nstd::cout << ones.take(3) << std::endl;\r\n\r\n// [1,1,1]\r\n```\r\n\r\nNote that `take()` returns a Collection, so we could also use any of the Collection manipulation methods on the result.\r\nThe `take()` method converts the Stream into a Collection by repeatedly requesting the head of the Stream, and if it doesn't exist, returning the head of the Stream constructed by the generator function.\r\n\r\nLet's try a more complex example.\r\nHere we generate the Fibonacci sequence.\r\n\r\n```cpp\r\nstd::function<Stream<int>(int, int)> fibs = [&](int prev, int curr) -> Stream<int> {\r\n    return Stream<int>(curr, [=]() -> Stream<int> {\r\n        return fibs(curr, prev + curr);\r\n    });\r\n};\r\nCollection<int> tenfibs = fibs(0, 1).take(3);\r\n\r\n// [1,1,2]\r\n```\r\n\r\nThe Stream generator `fibs`, when called with arguments `0` and `1`, creates a new Stream that has a head value of 1 and an internal pointer to the function `fibs(1, 1)`.\r\nThen, when we ask to `take(3)` elements from the Stream, the structure returns its head, and then lazily computes the remainder of the elements it needs to satisfy our request.\r\nIt does this by returning the result of its stored function pointer.\r\nIn this case, `tenfibs` would first return 1 becuase that is its head.\r\nIt would then return the head of the Stream that results from the evaluation of the function it stores a pointer to, namely `fibs(1, 1)`, which is 1.\r\nThe result of `fibs(1, 1)` also stores a pointer to another function, `fibs(1, 2)`.\r\nTo find the third and final value, the Stream will evaluate this function and return the resulting Stream's head, which is 2.\r\nFor a step-by-step visual depiction of the underlying state of our Stream during the `take(3)` function call, see the graphic below:\r\n\r\n```\r\ntenfibs.head      tenfibs.gen\r\n     1             fibs(0,1)\r\n     1             fibs(1,1)\r\n     2             fibs(1,2)\r\n     3             fibs(2,3)\r\n```\r\n\r\n## Non-Member Functions for Streams\r\n\r\n### Alternative Stream Creation Tactics\r\n\r\nUnfortunately, both examples above are rather verbose. \r\nC++11 does not allow the definition of recursive lambdas, so we have to define our Stream generators as `std::function` intead.\r\nThis creates a lot of syntax overhead to the definition of arbtrary Stream generator functions.\r\nIn order to ease the syntactic pain of this process, we implemented a series of helper functions to make this process more straightforward.\r\n\r\n`repeat()` is the simplest of these functions. It creates an infinite Stream of whatever value it is passed.\r\n\r\n```cpp\r\nstd::cout << repeat(1).take(5) << std::endl;\r\n\r\n// [1,1,1,1,1]\r\n```\r\n\r\nThe `from()` function takes two parameters, an initial value, and a step. \r\nIt then constructs a Stream starting at the initial value, incrementing by the step each time.\r\nIf the step is omitted from the function call, it defaults to 1.\r\n\r\n```cpp\r\nstd::cout << from(1).take(5) << std::endl;\r\n\r\n// [1,2,3,4,5]\r\n```\r\n\r\n```cpp\r\nstd::cout << from(1,2).take(5) << std::endl;\r\n\r\n// [1,3,5,7,9]\r\n```\r\n\r\n`iterate()` allows users to define an infinite Stream in terms of an initial value `x`, and a function `f`.\r\nThe Stream is then constructed as `x, f(x), f(f(x)), f(f(f(x)))...`.\r\n\r\n```cpp\r\nstd::cout << iterate(0, [](int x) { return x+1; }).take(5) << std::endl;\r\n\r\n// [0,1,2,3,4]\r\n```\r\n\r\nFinally, `recurrence()` is a generalized version of `iterate()`, which allows the user to define an infinite Stream in terms of any number of arguments, stored in a tuple, and a function that takes that tuple.\r\nHere is how we use `recurrence()` to rewrite our verbose definition of the Fibonacci Stream above.\r\n\r\n```cpp\r\nauto fibs = recurrence([](std::tuple<int,int> t) {\r\n    return std::get<0>(t) + std::get<1>(t);\r\n}, std::make_tuple(0, 1));\r\nstd::cout << fibs.take(5) << std::endl;\r\n\r\n// [0,1,1,2,3]\r\n```\r\n\r\n### Prepend Values\r\n\r\nAssume you want to add values to a Stream. \r\n`cons(T value, Stream<T> other)` prepends a value to a Stream.\r\n\r\n```cpp\r\nauto ints = from(1);\r\nstd:cout << cons(10, ints).take(5) << std::endl;\r\n\r\n// [10,1,2,3,4]\r\n```\r\n\r\nThis can also be done with the `&` operator.\r\nHowever, note that parentheses must be used appropriately because the operator is not defined as a member operator.\r\n\r\n```cpp\r\nauto ints = from(1);\r\nstd:cout << (10 & (20 & ints)).take(5) << std::endl;\r\n\r\n// [10,20,1,2,3]\r\n```\r\n\r\n\r\n### Zipping Streams\r\n\r\n`zip()` returns a Stream of tuples, where each tuple contains the elements of the zipped Streams that occur at the same position.\r\n`zipWith()` generalizes `zip()` by taking the function for zipping as the first argument instead of a tupling function.\r\n\r\nThese methods work in the exact same way as their Collection counterparts, except that they operatee on Streams instead.\r\n\r\n## Member Functions for Streams\r\n\r\n### List Processing Functions\r\n\r\nSimilar to Collections, we can call `head()` to return the first element of the Stream.\r\n\r\n```cpp\r\nstd::cout << from(1).head() << std::endl;\r\n\r\n// 1\r\n```\r\n\r\n`tail()` returns the Stream without the current head.\r\n\r\n```cpp\r\nstd::cout << from(1).tail().head() << std::endl;\r\n\r\n// 2\r\n```\r\n\r\n### Filtering Function\r\n\r\nJust like Collections, we can also `filter()` Streams.\r\n`filter()` simply returns a sub-Stream of elements of the Stream that match the predicate function provided.\r\n\r\n```cpp\r\nauto odds = from(1).filter([](int x) { return x % 2 != 0; }).take(5);\r\nstd::cout << odds << std::endl;\r\n\r\n// [1,3,5,7,9]\r\n```\r\n\r\n### Mapping function\r\n\r\nAgain, like Collections, `map()` allows us to return a Stream transformed according to the function we pass it.\r\n\r\nLet's create a list of the first five squares.\r\n\r\n```cpp\r\nauto squares = from(1).map([](int x) { return x * x; });\r\nstd::cout << squares.take(5) << std::endl;\r\n\r\n// [1,4,9,16,25]\r\n```\r\n\r\n## You're Done!\r\nYou've made it!\r\nThank you so much for reading through our tutorial highlighting the features, syntax, and code that drives our library.\r\nBy piping together the Collection and Stream methods you find here, you will be able to easily write complex, functional list operations in C++ with readability of a language like Scala.\r\n\r\nWe hope that C++ Collections will make functional programming concepts with both finite and infinite data structures more accessible and understandable to C++ programmers.\r\nIf you would like to contribute to the project it can be found [here][2]. \r\n\r\nThank you and stay posted for updates.\r\n\r\n<!-- Sources -->\r\n[repo_download]: https://github.com/natebrennand/cpp_collections/archive/master.zip\r\n[2]: https://github.com/natebrennand/cpp_collections/\r\n","google":"UA-36737775-2","note":"Don't delete this file! It's used internally to help with page regeneration."}